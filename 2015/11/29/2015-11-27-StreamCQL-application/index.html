	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>StreamCQL源码分析之application | 任何忧伤,都抵不过世界的美丽</title>
  <meta name="author" content="zqhxuyuan">
  
  <meta name="description" content="上篇在解析Schema的时候顺便分析了一些常用的Statement syntax和对应的语法/语义解析器结果,现在继续ApplicationBuilder.buildApplication中parseSchemas的下一步splitOperators.  
12345678910private vo">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="StreamCQL源码分析之application"/>
  <meta property="og:site_name" content="任何忧伤,都抵不过世界的美丽"/>

  
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  <!-- 百度统计 -->
  

  <!-- 谷歌统计 -->
  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">任何忧伤,都抵不过世界的美丽</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	<div class="col-md-8">
	  <!-- index -->
	  
			<h1>StreamCQL源码分析之application</h1>
			
			<div>
				<i class="fa fa-clock-o"></i>
				<span class="post-time">2015-11-29 16:23:04</span>
			</div>
			
	  

		<div class="content">
			<!-- index -->
		  
					<p>上篇在解析Schema的时候顺便分析了一些常用的Statement syntax和对应的语法/语义解析器结果,<br>现在继续ApplicationBuilder.buildApplication中parseSchemas的下一步splitOperators.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    app = <span class="keyword">new</span> Application(applicationName);</span><br><span class="line">    parseSchemas();</span><br><span class="line">    List&lt;SplitContext&gt; splitContexts = splitOperators();            <span class="comment">//拆分算子</span></span><br><span class="line">    SplitContext splitContext = combineOperators(splitContexts);    <span class="comment">//组合算子, 将拆分算子列表转换为只有一个SplitContext</span></span><br><span class="line">    changeUnionOperators(splitContext);</span><br><span class="line">    changeSchemaAfterAggregate(splitContext);</span><br><span class="line">    app.setOperators(splitContext.getOperators());                  <span class="comment">//拆分结果包含了operatots和transitions</span></span><br><span class="line">    app.setOpTransition(splitContext.getTransitions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>combineOperators会创建OperatorCombiner, 并调用combine方法将splitContexts合并起来,终于打印了日志中看到的:<code>combine all split contexts</code>(解析submit之后).<br>构建Application的主要工作就是Split和Combine,最后将SplitContext的operators和transitions设置到Application对象中,完成应用程序的构建,在这基础上再进行物理优化.    </p>
<h1 id="Application">Application</h1><h2 id="Split_and_Combine_Operators">Split and Combine Operators</h2><p>第一步SplitOperators拆分算子: 创建对应的Splitter,调用其split方法.   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SplitContext&gt; <span class="title">splitOperators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;SplitContext&gt; splitContexts = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">for</span> (AnalyzeContext pContext : parseContexts) &#123;         <span class="comment">//parseContexts是语义解析器结果列表</span></span><br><span class="line">        parseAutoCreatePipeStream(splitContexts, pContext); <span class="comment">//由于schema推断的存在,中间的流schema没有通过create input语句定义,所以显示的创建一个create input的解析内容</span></span><br><span class="line">        parseSubQueryOperators(splitContexts, pContext);    <span class="comment">//解析子查询</span></span><br><span class="line">        SplitContext context = OperatorSplitter.split(buildUtils, pContext);    <span class="comment">//算子拆分 ⬅️ </span></span><br><span class="line">        splitContexts.add(context);                         <span class="comment">//每个AnalyzeContext拆分后都对应一个SplitContext</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> splitContexts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>AnalyzeContext是CQL语句的语义解析结果, CQL的上下文信息都封装在语义解析结果里面.  由于语义解析是个比较大的切面,<br>需要把语义解析结果分成更细粒度, 即算子. 可以认为AnalyzeContext -&gt; SplitContext的转换是将任务更加具体化.  </p>
</blockquote>
<p>OperatorSplitter的splitters采用static块提前添加了系统中也有的算子拆分类. 结合上面的splitOperators就是一个双层循环了:<br>针对Application的每一个AnalyzeContext, 判断哪个Splitter可以解析这个AnalyzeContext(每个AnalyzeContext只会对应一个Splitter).   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SplitContext <span class="title">split</span><span class="params">(BuilderUtils buildUtils, AnalyzeContext parseContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Splitter splitter : splitters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (splitter.validate(parseContext)) &#123;</span><br><span class="line">            <span class="keyword">return</span> createSplitter(splitter.getClass(), buildUtils).split(parseContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个具体的Splitter都实现了validate方法根据传入的AnalyzeContext实现类(pContext)用来验证能否进行解析  </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Splitter                                AnalyzeContext</span><br><span class="line">    |<span class="string">-- SelectSplitter                      </span>|<span class="string">-- SelectAnalyzeContext     </span><br><span class="line">            </span>|<span class="string">-- DataSourceSplitter          </span>|</span><br><span class="line">            |<span class="string">-- AggregateSplitter           </span>|</span><br><span class="line">            |<span class="string">-- JoinSplitter                </span>|</span><br><span class="line">    |<span class="string">-- InsertSplitter                      </span>|<span class="string">-- InsertAnalyzeContext &gt;&gt; InsertOnlyAnalyzeContext</span><br><span class="line">    </span>|<span class="string">-- SourceOperatorSplitter              </span>|<span class="string">-- CreateStreamAnalyzeContext</span><br><span class="line">    </span>|<span class="string">-- MultiInsertSplitter                 </span>|<span class="string">-- MultiInsertStatementAnalyzeContext</span><br><span class="line">    </span>|<span class="string">-- UserOperatorSplitter                </span>|<span class="string">-- InsertUserOperatorStatementAnalyzeContext</span></span><br></pre></td></tr></table></figure>
<p>比如AggregateSplitter的validate方法会验证是不是SelectAnalyzeContext.     </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(AnalyzeContext parseContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(parseContext <span class="keyword">instanceof</span> SelectAnalyzeContext))    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    SelectAnalyzeContext selectAnalyzeContext = (SelectAnalyzeContext)parseContext;</span><br><span class="line">    FromClauseAnalyzeContext clauseContext = selectAnalyzeContext.getFromClauseContext();</span><br><span class="line">    <span class="keyword">if</span> (clauseContext.getJoinexpression() != <span class="keyword">null</span>)          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (clauseContext.getCombineConditions().size() != <span class="number">0</span>)   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//属于select,然后既不是combine，又不是join，那么就是aggregate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>普通的select可以看做是aggregate,比如<code>select count(id) from a where</code>就是一种聚合. 因为select子句是count(id)<br>但是如果是<code>select id from a join b on a.id=b.id</code>因为有join操作就不是aggregate了.<br>所以可以看到SelectSplitter针对这两种语句分成了AggregateSplitter和JoinSplitter.  </p>
</blockquote>
<p>只有验证成功,才可以在此Splitter上调用split: 根据AnalyzeContext创建Operator算子, 即根据语义分析结果拆分内容</p>
<h3 id="SourceOperatorSplitter_-&gt;_Input/Output_Operator">SourceOperatorSplitter -&gt; Input/Output Operator</h3><p>SourceOperatorSplitter的split会创建Input和Output算子和临时的pipe算子.   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceOperatorSplitter</span> <span class="keyword">implements</span> <span class="title">Splitter</span> </span>&#123;   <span class="comment">//源算子拆分,包括输入算子和输出算子</span></span><br><span class="line">    <span class="keyword">private</span> SplitContext result = <span class="keyword">new</span> SplitContext();</span><br><span class="line">    <span class="keyword">private</span> CreateStreamAnalyzeContext context;             <span class="comment">//由validate保证,所以下面的split方法可以强转</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SplitContext <span class="title">split</span><span class="params">(AnalyzeContext parseContext)</span> </span>&#123;</span><br><span class="line">        context = (CreateStreamAnalyzeContext)parseContext;  <span class="comment">//语义解析结果</span></span><br><span class="line">        setParallelNumber();</span><br><span class="line">        addToInput();                       <span class="comment">//创建输入算子并加入到result中: InputStreamOperator</span></span><br><span class="line">        addToOutput();                      <span class="comment">//创建输出算子并加入到result中: OutputStreamOperator</span></span><br><span class="line">        addToPipe();                        <span class="comment">//连接算子: FilterOperator</span></span><br><span class="line">        result.setParseContext(context);    <span class="comment">//最后都要将AnalyzeContext设置到SplitContext中,说不定后面还是需要它的父亲(context)站出来撑腰呢.</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上篇语法结构的<code>C</code>部分,AnalyzeContext.analyze会将<code>语法解析的上下文结果</code>设置到<code>语义解析结果</code>中. 这里创建的<code>算子</code>则进一步依赖于语义解析结果.<br>所谓任何事物都是可以追朔到源头的: <strong><code>StatementContext-&gt;AnalyzeContext-&gt;Operator-&gt;SplitContext-&gt;Application</code></strong>, Operator并不是一步登天,与生俱来的.<br>可以看到context中的RecordReaderClass,DeserializerClass,ReadWriterProperties,SerDeProperties依次<code>登场</code>并进入到Operator的<code>戏局</code>里.<br>所以Operator沿袭了<code>祖先</code>的上下文数据, 现在新的世界格局将是以Operator为<code>主角</code>的了, 祖先们就可以<code>隐退江湖</code>了.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToInput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context.getDeserializerClassName() != <span class="keyword">null</span> &amp;&amp; context.getSerializerClassName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Operator inop = createInputSourceOperator();    <span class="comment">//创建算子</span></span><br><span class="line">        <span class="keyword">if</span> (inputConverter.validate(inop)) &#123;</span><br><span class="line">            inop = inputConverter.convert(inop);</span><br><span class="line">        &#125;</span><br><span class="line">        result.addOperators(inop);      <span class="comment">//这个很重要,将新创建的算子添加到SplitContext中, 后面才会在设置到Application中 ⬅️ </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InputStreamOperator <span class="title">createInputSourceOperator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String operatorName = getOperatorName(context.getRecordReaderClassName(),<span class="string">"Input"</span>);</span><br><span class="line">    <span class="comment">//创建输入流算子</span></span><br><span class="line">    InputStreamOperator op = <span class="keyword">new</span> InputStreamOperator(buildUtils.getNextOperatorName(operatorName), parallelNumber);</span><br><span class="line">    <span class="comment">//设置输入算子的属性: 反序列化类, 读取记录类</span></span><br><span class="line">    op.setName(context.getStreamAlias());</span><br><span class="line">    op.setDeserializerClassName(context.getDeserializerClassName());</span><br><span class="line">    op.setRecordReaderClassName(context.getRecordReaderClassName());</span><br><span class="line">    <span class="comment">//反序列化类的属性和读取记录的属性, 对应CQL最原始的properties. </span></span><br><span class="line">    op.setArgs(<span class="keyword">new</span> TreeMap&lt;String, String&gt;());</span><br><span class="line">    op.getArgs().putAll(context.getReadWriterProperties());</span><br><span class="line">    op.getArgs().putAll(context.getSerDeProperties());</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pipe stream算子属于中间算子，本来是不会对应任何算子，只要解析出schema即可的. 但是为了和CQL的整体规则一致，便于后面创建算子之间的连线，<br>所以这里创建一个空的filter算子，不带任何过滤。 这样，就可以在优化器阶段将这个filter算子优化掉  </p>
<p>每个operator的参数用一个Map args来保存, 比如上面输入算子的参数包括了ReadWriterProperties和SerDeProperties.<br>因为执行器不知道每个operator中到底需要哪些参数，所以只能都放在map中, 由上层客户端进行填充，并在底层运行时检测</p>
</blockquote>
<h3 id="InsertSplitter_-&gt;_Insert_Operator">InsertSplitter -&gt; Insert Operator</h3><p>insert into语句的AnalyzeContext包含了outputStreamName和select子句, 输出流可以直接设置到SplitContext结果中. 而select子句需要<br>再次调用查询相关的Splitter(返回值也是SplitContext), 并将其结果产生的operators和transitions添加到insert的SplitContext中.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSplitter</span> <span class="keyword">implements</span> <span class="title">Splitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InsertAnalyzeContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SplitContext <span class="title">split</span><span class="params">(AnalyzeContext parseContext)</span> </span>&#123;</span><br><span class="line">        context = (InsertAnalyzeContext)parseContext;</span><br><span class="line">        result.setOutputStreamName(context.getOutputStreamName());</span><br><span class="line">        <span class="comment">//insert中包含了select, 所以要先创建select算子, 调用SelectSplitter.split</span></span><br><span class="line">        SplitContext selectResult = OperatorSplitter.split(buildUtils, context.getSelectContext());</span><br><span class="line">        <span class="comment">//将select的结果算子和连接都加入到insert算子中</span></span><br><span class="line">        result.getOperators().addAll(selectResult.getOperators());</span><br><span class="line">        result.getTransitions().addAll(selectResult.getTransitions());</span><br><span class="line">        result.setParseContext(context);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SourceOperatorSplitter和InsertSplitter设置到SplitContext result中的内容并不是一样的. 这是由于不同的AnalyzeContext所存储的<br>数据也是不同的, 数据源只需要序列化类,读取类等. 而插入语句则有输出流和输入源(select). 所以你<code>吃的是什么草, 挤出来的奶也是不一样的</code>.  </p>
</blockquote>
<h3 id="SelectSplitter">SelectSplitter</h3><p>SelectSplitter包含了DataSource,Aggregate,JoinSplitter.针对select语句的拆分以及Schema分为:  </p>
<p>1、最一般的select子句。<br>只有一个schema, 输入和输出都是(同)一个schema, 不论有没有窗口，都必须放在聚合算子(AggregateSplitter)中。<br>只要有where，就都放在functor算子(表达式)中，在优化器中，再进行调整，可以改为filter或者继承再聚合算子中。  </p>
<blockquote>
<p>单单一个select为什么要添加聚合算子?<br>答: 聚合不一定就是group by, 可能是filter过滤,limit限制条数等.<br>而select后面是可以跟上filter或者limit等. 聚合还可以是count,sum等.  </p>
</blockquote>
<p>2、Join: 多个Join的schema，一个outputschema. 先查询出多个表所有的列，再在functor算子中进行列过滤。<br>3、Groupby: 聚合算子<br>4、orderby: 同一般select子句<br>5、Join语句中不支持聚合和groupby，至少目前不支持<br>6、三种过滤<br>窗口之后的过滤：where，放在聚合算子中<br>窗口之前的过滤：filter，前面加一个filter算子, 但是这样就牵扯到schema的变化，这个就麻烦一些了。先解析出所有的列，再进行过滤。<br>聚合之后的过滤：having，放在聚合算子中  </p>
<p>总结下：<br>1、聚合算子是必须有的。<br>2、Orderby必须放在独立sort算子中<br>3、limit放在output中作为限制，但是目前还不支持。<br>4、一个select语句，如论如何拆分，都只有一个输出schema. 至少目前是这样，后面在优化器中会进行调整，将where中的一些列加入到select中，进行一些列变换。<br>5、Join时候，先查询该流所有列的Join结果，之后再进行列过滤。<br>6、Sort、Join、Aggregate算子都是按照字段进行分发，其他都是随机分发。  </p>
<p>抽象类SelectSplitter的splitFromClause交给子类自己去实现:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSplitter</span> <span class="keyword">implements</span> <span class="title">Splitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SplitContext result = <span class="keyword">new</span> SplitContext();       <span class="comment">//算子的拆分结果, 数据主要由AnalyzeContext而来</span></span><br><span class="line">    <span class="keyword">private</span> SelectAnalyzeContext selectAnalyzeContext;      <span class="comment">//AnalyzeContext语义解析结果    </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SplitContext <span class="title">split</span><span class="params">(AnalyzeContext parseContext)</span> </span>&#123;</span><br><span class="line">        initParameters(parseContext);   <span class="comment">//初始化, 由于Select语句包含了很多子句,因此还要在这里定义其他子句的AnalyzeContext.</span></span><br><span class="line">        setParallelNumber();</span><br><span class="line">        splitFromClause();              <span class="comment">//抽象方法</span></span><br><span class="line">        result.setParseContext(selectAnalyzeContext);       <span class="comment">//设置到SplitContext结果中</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectClauseAnalyzeContext selectClauseContext; <span class="comment">//既然要解析Slect语句,就要解析它包含的所有子句! 正如前面的insert也要先获得select!</span></span><br><span class="line">    <span class="keyword">private</span> FromClauseAnalyzeContext fromClauseContext;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initParameters</span><span class="params">(AnalyzeContext parseContext)</span> </span>&#123;</span><br><span class="line">        selectAnalyzeContext = (SelectAnalyzeContext)parseContext;</span><br><span class="line">        selectClauseContext = selectAnalyzeContext.getSelectClauseContext();</span><br><span class="line">        fromClauseContext = selectAnalyzeContext.getFromClauseContext();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于层级嵌套: 比如insert中嵌套了select. 所以解析insert时要先解析select,再把select设置到insert中.<br>同样select语句包含了更多的子句,比如select子句,from子句, 所以也要把旗下包含的所有子句都解析完了,自己才是完整的可用的.   </p>
</blockquote>
<h3 id="AggregateSplitter_-&gt;_FilterOp_+_AggregateOp_+_Transition">AggregateSplitter -&gt; FilterOp + AggregateOp + Transition</h3><p>AggregateSplitter的父类是SelectSplitter, 而Select包含From子句. From中可以有①FilterOperator: <code>filter before window</code><br>流前的过滤: <code>FROM transform (evnetid&gt;10)[range UNBOUNDED]</code>. 其中[]表示window, 而[]前面的()则是filter过滤.<br>②拆分AggregateOperator, 因为聚合算子可能包括多种聚合操作, 如果存在则都设置到AggregateOperator对应的字段中.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">splitFromClause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取Select中From子句的语义解析结果</span></span><br><span class="line">    FromClauseAnalyzeContext clauseContext = getFromClauseContext();    <span class="comment">//定义在父类SelectSplitter中,初始化时由Select获取</span></span><br><span class="line">    String streamName = clauseContext.getInputStreams().get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//① 在Window操作前可以有Filter操作, 拆分出Filter算子, 在父类SelectSplitter中实现</span></span><br><span class="line">    FilterOperator fop = splitFiterBeforeWindow(streamName);</span><br><span class="line">    <span class="comment">//② 聚合算子</span></span><br><span class="line">    AggregateOperator aggregateOperator = splitAggregateOperator(clauseContext, streamName);</span><br><span class="line">    <span class="comment">//③ 创建算子之间的连接</span></span><br><span class="line">    OperatorTransition transition = createTransition(fop, aggregateOperator, streamName);</span><br><span class="line">    </span><br><span class="line">    getResult().addOperators(fop);                  <span class="comment">//过滤算子</span></span><br><span class="line">    getResult().addOperators(aggregateOperator);    <span class="comment">//聚合算子</span></span><br><span class="line">    getResult().addTransitions(transition);         <span class="comment">//从过滤算子到聚合算子的连线</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> FilterOperator <span class="title">splitFiterBeforeWindow</span><span class="params">(String streamName)</span> </span>&#123;</span><br><span class="line">    FromClauseAnalyzeContext clauseContext = getFromClauseContext();</span><br><span class="line">    <span class="comment">//新创建一个Filter过滤算子, from stream(id&gt;1)[RANGE 10s] 可以在流之后,窗口之前的中间存在Filter过滤: 在进入窗口前过滤</span></span><br><span class="line">    FilterOperator fop = <span class="keyword">new</span> FilterOperator(buildUtils.getNextOperatorName(<span class="string">"Filter"</span>), parallelNumber);</span><br><span class="line">    <span class="comment">//从From语义解析结果中获取filterBeforeWindow对应当前stream的filter表达式,比如上面的id&gt;1</span></span><br><span class="line">    ExpressionDescribe expression = clauseContext.getFilterBeForeWindow().get(streamName);</span><br><span class="line">    fop.setFilterExpression(expression.toString());                     <span class="comment">//过滤条件表达式,比如id&gt;1</span></span><br><span class="line">    fop.setOutputExpression(createFilterOutputExpression(streamName));  <span class="comment">//输出列</span></span><br><span class="line">    <span class="keyword">return</span> fop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> AggregateOperator <span class="title">splitAggregateOperator</span><span class="params">(FromClauseAnalyzeContext clauseContext, String streamName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建新的聚合算子</span></span><br><span class="line">    AggregateOperator aggop = <span class="keyword">new</span> AggregateOperator(getBuildUtils().getNextOperatorName(<span class="string">"Aggregator"</span>), getParallelNumber());</span><br><span class="line">    parseWindow(clauseContext, streamName, aggop);  <span class="comment">//解析窗口. Window其实也是From的一部分,所以需要从From子句中获取Windows设置到aggop里</span></span><br><span class="line">    parseWhere(aggop);                              <span class="comment">//解析过滤: setFilterBeforeAggregate,在聚合之前的过滤.</span></span><br><span class="line">    aggop.setFilterAfterAggregate(parseHaving());   <span class="comment">//解析having</span></span><br><span class="line">    aggop.setGroupbyExpression(parseGroupby());     <span class="comment">//解析分组</span></span><br><span class="line">    aggop.setOrderBy(parseOrderBy());               <span class="comment">//解析排序</span></span><br><span class="line">    aggop.setLimit(parseLimit());                   <span class="comment">//解析限制</span></span><br><span class="line">    aggop.setOutputExpression(getSelectClauseContext().toString());     <span class="comment">//输出表达式: select关键字后面的都是输出</span></span><br><span class="line">    <span class="keyword">return</span> aggop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>AggregateOperator对Select子句的解析最后都是字符串.  </p>
</blockquote>
<table>
<thead>
<tr>
<th>aggregation</th>
<th>setXXX</th>
<th>AnalyzerContext</th>
<th>parseXXX</th>
</tr>
</thead>
<tbody>
<tr>
<td>window</td>
<td>setWindow</td>
<td>FromClauseAnalyzeContext.windows.get(streamName)</td>
<td>parseWindow</td>
</tr>
<tr>
<td>where</td>
<td>setFilterBeforeAggregate</td>
<td>FilterClauseAnalzyeContext whereClauseContext</td>
<td>parseWhere</td>
</tr>
<tr>
<td>having</td>
<td>setFilterAfterAggregate</td>
<td>FilterClauseAnalzyeContext havingClauseContext</td>
<td>parseHaving</td>
</tr>
<tr>
<td>group by</td>
<td>setGroupbyExpression</td>
<td>SelectClauseAnalyzeContext groupbyClauseContext</td>
<td>parseGroupby</td>
</tr>
<tr>
<td>order by</td>
<td>setOrderBy</td>
<td>OrderByClauseAnalyzeContext</td>
<td>parseOrderBy</td>
</tr>
<tr>
<td>limit</td>
<td>setLimit</td>
<td>LimitClauseAnalzyeContext</td>
<td>parseLimit</td>
</tr>
<tr>
<td>output exp</td>
<td>setOutputExpression</td>
<td>SelectClauseAnalyzeContext selectClauseContext</td>
<td>getSelectClauseContext</td>
</tr>
</tbody>
</table>
<p>通过上面的AggregateSplitter.split方法,我们知道了聚合算子由FilterBeforeWindow,Window,FilterBeforeAggregate,Having,GroupBy,OrderBy,Limit组成.  </p>
<blockquote>
<p>语法结构中并没有Aggregate这种类型, 但是我们发现Aggregate用到的这些和Select语句中包含的子句都差不多. 其中两个Window可以认为是From子句.<br>FilterBeforeAggregate是Where子句, 这样Select语句的所有部分就和Aggregate都吻合了! 所以说Select也是一种Aggregate! (^_^这不是巧合吧) </p>
</blockquote>
<h4 id="AggregateOperator">AggregateOperator</h4><p><img src="http://img.blog.csdn.net/20151126173430754" alt="stream-operators"></p>
<p>AggregateOperator聚合算子:包含了window,以及window前后的filter操作. 当然还少不了count,sum之类的UDAF函数计算和UDF函数计算(BasicAggFunctionOperator)<br>AggregateOperator &gt;&gt; BasicAggFunctionOperator &gt;&gt; InnerFunctionOperator 这些类的字段正好对应了聚合算子的所有组成部分.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AggregateOperator</span> <span class="keyword">extends</span> <span class="title">BasicAggFunctionOperator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Window window;                  <span class="comment">//窗口 ==&gt; From子句</span></span><br><span class="line">    <span class="keyword">private</span> String filterBeforeAggregate;   <span class="comment">//filter的过滤条件 ==&gt; Where子句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicAggFunctionOperator</span> <span class="keyword">extends</span> <span class="title">InnerFunctionOperator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filterAfterAggregate;    <span class="comment">//聚合类的过滤条件, 这里都是udaf函数, 过滤一定发生在数据聚合之后, 这里的表达式一定使用的是outputSchema中的列名称</span></span><br><span class="line">    <span class="keyword">private</span> String groupbyExpression;       <span class="comment">//分组的表达式</span></span><br><span class="line">    <span class="keyword">private</span> String orderBy;                 <span class="comment">//排序: 允许有多个字段，之间按照逗号分割, 允许出现udf和udaf函数</span></span><br><span class="line">    <span class="keyword">private</span> Integer limit;                  <span class="comment">//窗口的输出限制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerFunctionOperator</span> <span class="keyword">extends</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String outputExpression;        <span class="comment">//输出的列定义,不光有单纯的列，还有udf以及udaf函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过滤条件是一个字符串形式的逻辑表达式, 允许有and,or以及大括号和udf函数, 但是绝对不允许出现udaf函数，因为这没有聚合操作<br><strong>过滤发生在数据进入窗口之后，聚合之前</strong>. 比如 (a&gt;1 and a &lt;100) or (b is not null) 就是where的过滤， </p>
<p>InnerFunctionOperator功能性算子，主要为系统提供window，join，order by，group by等聚合操作。<br>这里的名称和operator包中的不一样. 这里定义的这些operator，主要是进行执行计划的序列化和反序列化的。<br>所有的数据类型全部是<code>字符串类型</code>，之后还要经过语法的解析，物理执行计划的优化之后，才会在application中提交。 </p>
<h4 id="Transition">Transition</h4><p>别忘了,还有createTransition创建连线哦: 在AggregateSplitter.splitFromClause中fromOp是FilterBeforeWindow FilterOperator, toOp是AggregateOperator.  </p>
<p>算子之间进行连接, 涉及到分组策略, Storm中Bolt可以指定怎么根据输入源进行分组, 即输入源将数据怎么分流到当前Bolt. 分组是有一定依据的,不能胡乱连接.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> OperatorTransition <span class="title">createTransition</span><span class="params">(Operator fromOp, Operator toOp, String streamName)</span> </span>&#123;</span><br><span class="line">    FromClauseAnalyzeContext clauseContext = getFromClauseContext();</span><br><span class="line">    DistributeType distype = DistributeType.SHUFFLE;</span><br><span class="line">    String disFields = <span class="keyword">null</span>;</span><br><span class="line">    Schema schema = clauseContext.getInputSchemas().get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果有GroupBy,分组策略就是字段分组(distype=FIELDS), 比如group by type, 则按照type字段分组(disFields=type).  </span></span><br><span class="line">    <span class="keyword">if</span> (getGroupbyClauseContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        disFields = removeDataSourceColumnsFromGroupbyExpression(schema, getGroupbyClauseContext().toString());</span><br><span class="line">        distype = DistributeType.FIELDS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//现在是在SelectSpiltter中, 所以可能是Aggregate,Join,DataSource中任意一种.  </span></span><br><span class="line">    <span class="keyword">if</span> (toOp <span class="keyword">instanceof</span> JoinFunctionOperator) &#123;</span><br><span class="line">        List&lt;Schema&gt; inputSchemas = getFromClauseContext().getInputSchemas();</span><br><span class="line">        schema = BaseAnalyzer.getSchemaByName(streamName, inputSchemas);</span><br><span class="line">        <span class="keyword">if</span> (((JoinFunctionOperator)toOp).getJoinType() != JoinType.CROSS_JOIN) &#123;</span><br><span class="line">            disFields = getJoinExpression(schema);</span><br><span class="line">            distype = DistributeType.FIELDS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建起始算子到结束算子之间的连线, 并确定分组策略,分组字段, 发起连接的算子的schema信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OperatorTransition(buildUtils.getNextStreamName(), fromOp, toOp, distype, disFields, schema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在似乎要逐步用Storm的例子来理解了,否则算子之间为什么要进行连接? 连接之后就确定了上游算子怎么发送数据到下游算子. 假设Storm有两个Bolt: Bolt1和Bolt2.<br>Bolt1过滤数据,输出(word,count)两个字段. 为了能使得对Bolt1过滤后的数据进行分流,Bolt2使用Bolt1的word字段进行FieldGrouping. 这样Bolt1相同的word字段<br>只会到相同的Bolt任务中, 不同的word字段会分发到不同的Bolt2任务. 所以可以把Bolt1看做过滤算子, Bolt2看做是聚合算子, 中间存在分组连接对Bolt1的数据分流.  </p>
<p>那么具体下游算子要怎么接收上游算子的数据呢? 不用担心! 这里先只是创建连接,只要有连接,就都好办了,找对关系找对门路是最重要的!</p>
</blockquote>
<h4 id="SplitContext">SplitContext</h4><p>现在不难看出SplitContext的作用是各类语义分析结果拆分内容. 和前面几个XXXContext一样都只是保存数据的介质(还记得StatementContext,AnalyzeContext吗)  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OperatorTransition&gt; transitions = <span class="keyword">new</span> ArrayList&lt;OperatorTransition&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Operator&gt; operators = <span class="keyword">new</span> ArrayList&lt;Operator&gt;();</span><br><span class="line">    <span class="keyword">private</span> String outputStreamName;        <span class="comment">//输出的流名称: 指的是在CQL中显示指定输出流名称的。例如insert into 之类的语句</span></span><br><span class="line">    <span class="keyword">private</span> AnalyzeContext parseContext;    <span class="comment">//CQL解析结果: 通过这个结果，可以进行多个CQL之间的连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每一条CQL语句都对应一个AnalyzeContext, 每个AnalyzeContext都有一个Splitter用来创建算子. 即使上面我们创建了Transition连接, 但也是在同一个CQL语句内的!<br>而一个完整的Topology是要求能把多个CQL语句的上下文都串联起来组成一个DAG图的. 所以这就是在SplitContext中保留AnalyzeContext的含义: 呼叫Combine!  </p>
</blockquote>
<h3 id="OperatorCombiner">OperatorCombiner</h3><p>现在我们知道为什么要进行合并了,因为如果仅仅是拆分每一条CQL语句, 这样最后都是一段一段的,我们需要把这些一段一段拼接成完整的图.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SplitContext <span class="title">combine</span><span class="params">(List&lt;SplitContext&gt; splitContexts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; splitContexts.size(); i++) &#123;</span><br><span class="line">        combineSplitContext(splitContexts.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineSplitContext</span><span class="params">(SplitContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原始每一条CQL的算子和连线不能被破坏的! 要重新加入最后的返回结果中. </span></span><br><span class="line">    result.getOperators().addAll(context.getOperators());</span><br><span class="line">    result.getTransitions().addAll(context.getTransitions());</span><br><span class="line">    <span class="comment">//如果是SourceOperatorSplitter对应的CreateStreamAnalyzeContext, 是没有transition的.  </span></span><br><span class="line">    <span class="keyword">if</span> (context.getParseContext() <span class="keyword">instanceof</span> CreateStreamAnalyzeContext)&#123;</span><br><span class="line">        addSchemasFromCreateStream(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并时新添加的只是CQL与CQL之间的连线! 对于算子已经都是完整的了,不会缺胳膊断腿的,不需要再添加.  </span></span><br><span class="line">    createTransition(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Splitter中SourceOperatorSplitter是没有operators和transitions, InsertSplitter的算子和连线则依赖于SelectSpitter.  </p>
</blockquote>
<p>将多个算子组合起来, 组建算子之间的上下级关系. 算子之间的连线，有两种来源：<br>1、算子是由<code>一条CQL语句</code>拆分出多个算子组成，这样，连线就可以在拆分的时候确定。<br>2、算子是由<code>多条CQL语句</code>组合而来，通过使用<code>insert into select from</code>这样的语句，就可以实现多个算子之间的级联。<br>甚至可以改变算子之间的连接关系。比如在aggregate算子之前加入union算子, 在aggregate算子之后加入split算子。  </p>
<p>为每个<code>insert into select</code>语句解析出来的结果加入上下文连线。<br>CQL语句之间的连线，必然从inputStream或者PipeStream发起，连接到outputStream或者PipeStream.  </p>
<p><img src="http://img.blog.csdn.net/20151129160212682" alt="input-pipe-output"></p>
<h4 id="PipeStream">PipeStream</h4><p>splitOperators在拆分之前, 会首先解析是否需要创建之前没有声明过的流. 如果不存在,则创建PipeStream.   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAutoCreatePipeStream</span><span class="params">(List&lt;SplitContext&gt; splitContexts, AnalyzeContext pcontext)</span> </span>&#123;</span><br><span class="line">    parseAutoCreatePipeStreamForInsert(splitContexts, pcontext);</span><br><span class="line">    parseAutoCreatePipeStreamForMultiInsert(splitContexts, pcontext);</span><br><span class="line">    parseAutoCreatePipeStreamForUserOperator(splitContexts, pcontext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAutoCreatePipeStreamForInsert</span><span class="params">(List&lt;SplitContext&gt; splitContexts, AnalyzeContext pcontext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pcontext <span class="keyword">instanceof</span> InsertAnalyzeContext) &#123;</span><br><span class="line">        InsertAnalyzeContext ipc = (InsertAnalyzeContext)pcontext;</span><br><span class="line">        <span class="keyword">if</span> (!ipc.isPipeStreamNotCreated()) <span class="keyword">return</span>;      <span class="comment">//允许类型不是输入/输出流的流不存在   </span></span><br><span class="line">        SplitContext sc = createPipeStreamSplitContext(ipc.getOutputSchema());</span><br><span class="line">        splitContexts.add(sc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> SplitContext <span class="title">createPipeStreamSplitContext</span><span class="params">(Schema schema)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="string">"create pipe Stream while stream is not created!"</span>);</span><br><span class="line">    CreateStreamAnalyzeContext pipe = <span class="keyword">new</span> CreateStreamAnalyzeContext();</span><br><span class="line">    pipe.setSchema(schema);</span><br><span class="line">    pipe.setStreamName(schema.getId());</span><br><span class="line">    <span class="keyword">return</span> OperatorSplitter.split(buildUtils, pipe);    <span class="comment">//输入输出流使用SourceOperatorSplitter拆分算子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SubQuery">SubQuery</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSubQueryOperators</span><span class="params">(List&lt;SplitContext&gt; splitContexts, AnalyzeContext pcontext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pcontext <span class="keyword">instanceof</span> InsertAnalyzeContext) &#123;</span><br><span class="line">        InsertAnalyzeContext ipc = (InsertAnalyzeContext)pcontext;</span><br><span class="line">        parseStreamContextInSubQuery(splitContexts, ipc);</span><br><span class="line">        parseInsertContextInSubQuery(splitContexts, ipc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseStreamContextInSubQuery</span><span class="params">(List&lt;SplitContext&gt; splitContexts, InsertAnalyzeContext ipc)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, CreateStreamAnalyzeContext&gt; subCreateStreamContexts = ipc.getSelectContext().getFromClauseContext().getSubQuerySchemas();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, CreateStreamAnalyzeContext&gt; et : subCreateStreamContexts.entrySet()) &#123;</span><br><span class="line">        SplitContext context = OperatorSplitter.split(buildUtils, et.getValue());</span><br><span class="line">        splitContexts.add(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseInsertContextInSubQuery</span><span class="params">(List&lt;SplitContext&gt; splitContexts, InsertAnalyzeContext ipc)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, InsertAnalyzeContext&gt; subs = ipc.getSelectContext().getFromClauseContext().getSubQueryForStream();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, InsertAnalyzeContext&gt; et : subs.entrySet()) &#123;</span><br><span class="line">        InsertAnalyzeContext insertContext = et.getValue();</span><br><span class="line">        insertContext.getSelectContext().setParallelClauseContext(ipc.getSelectContext().getParallelClauseContext());</span><br><span class="line">        parseSubQueryOperators(splitContexts, et.getValue());</span><br><span class="line">        SplitContext context = OperatorSplitter.split(buildUtils, insertContext);</span><br><span class="line">        splitContexts.add(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="From_&amp;_To_Transition">From &amp; To Transition</h4><p>首先找到insert into语句中计算出来的连线的起点。找到对应的算子. 然后根据起点的schema名称，找到对应的流名称，创建连线  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createFromTransition</span><span class="params">(SplitContext context, InsertAnalyzeContext insertContext)</span> </span>&#123;</span><br><span class="line">    List&lt;OperatorTransition&gt; startTransitions = context.getFirstTransitons();</span><br><span class="line">    <span class="keyword">for</span> (OperatorTransition transition : startTransitions) &#123;</span><br><span class="line">        Operator op = context.getOperatorById(transition.getFromOperatorId());</span><br><span class="line">        String startStreamName = transition.getSchemaName();</span><br><span class="line">        SplitContext fromContext = getFromSplitContext(startStreamName);</span><br><span class="line">        Schema schema = getInputSchema(startStreamName, insertContext);</span><br><span class="line">        String nextStreamName = buildUtils.getNextStreamName();</span><br><span class="line">        </span><br><span class="line">        Operator fromOp = fromContext.getLastOperator();</span><br><span class="line">        OperatorTransition fromtransition = <span class="keyword">new</span> OperatorTransition(nextStreamName, fromOp, op, DistributeType.SHUFFLE, <span class="keyword">null</span>, schema);</span><br><span class="line">        result.addTransitions(fromtransition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createToTransition</span><span class="params">(SplitContext context, InsertAnalyzeContext insertContext)</span> </span>&#123;</span><br><span class="line">    Set&lt;Operator&gt; ops = getLastOperator(context);</span><br><span class="line">    <span class="keyword">for</span> (Operator op : ops) &#123;</span><br><span class="line">        String startStreamName = insertContext.getOutputStreamName();</span><br><span class="line">        SplitContext toContext = getToSplitContext(startStreamName);</span><br><span class="line">        Schema schema = insertContext.getOutputSchema();</span><br><span class="line">        String nextStreamName = buildUtils.getNextStreamName();</span><br><span class="line">        </span><br><span class="line">        Operator toOp = toContext.getFirstOperator();</span><br><span class="line">        OperatorTransition totransition = <span class="keyword">new</span> OperatorTransition(nextStreamName, op, toOp, DistributeType.SHUFFLE, <span class="keyword">null</span>, schema);</span><br><span class="line">        result.addTransitions(totransition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="submitApplication">submitApplication</h2><p>历经千辛万苦, 终于回到SubmitTask的submitApplication, 创建物理计划Executor,并执行Application.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> PhysicalPlanExecutor().execute(context.getApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="api-Application_-&gt;_application-Application">api.Application -&gt; application.Application</h4><p>api的Application是流处理执行计划应用程序, 封装的是CQL语句构建而成的应用程序:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;                      </span><br><span class="line">    <span class="keyword">private</span> String applicationId = <span class="keyword">null</span>;                    <span class="comment">//应用id</span></span><br><span class="line">    <span class="keyword">private</span> String applicationName = <span class="keyword">null</span>;                  <span class="comment">//应用名称</span></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;String, String&gt; confs;                  <span class="comment">//整个应用程序中用到的配置属性,也包含用户自定义的配置属性</span></span><br><span class="line">    <span class="keyword">private</span> String[] userFiles;                             <span class="comment">//用户自定义添加的一些文件</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserFunction&gt; userFunctions;               <span class="comment">//用户自定义的函数,udf和udaf都在这个里面</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Schema&gt; schemas = <span class="keyword">new</span> ArrayList&lt;Schema&gt;(); <span class="comment">//执行计划中的所有的schema</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Operator&gt; operators = <span class="keyword">null</span>;                <span class="comment">//执行计划中所有的操作,包含输入、输出和计算操作      </span></span><br><span class="line">    <span class="keyword">private</span> List&lt;OperatorTransition&gt; opTransition = <span class="keyword">null</span>;   <span class="comment">//整个执行计划中所有的连接线，定义了operator之间的连接关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>application.Application针对Schema和算子采用Manager管理类(实际上底层的存储结构都是由Map构成的)来操作:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String appName;                 <span class="comment">//应用程序名称</span></span><br><span class="line">    <span class="keyword">private</span> EventTypeMng streamSchema;      <span class="comment">//所有Schema集合</span></span><br><span class="line">    <span class="keyword">private</span> OperatorMng operatorManager;    <span class="comment">//算子集合</span></span><br><span class="line">    <span class="keyword">private</span> StreamingConfig conf;           <span class="comment">//系统级别的配置属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OperatorMng管理的算子包括输入算子(addInputStream),输出算子(addOutputStream),功能算子(addFunctionStream).  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IRichOperator (com.huawei.streaming.operator)</span><br><span class="line">    AbsOperator (com.huawei.streaming.operator)</span><br><span class="line">        FunctionOperator (com.huawei.streaming.operator)    <span class="comment">//功能算子</span></span><br><span class="line">            JoinFunctionOp (com.huawei.streaming.operator.functionstream)</span><br><span class="line">                DataSourceFunctionOp (com.huawei.streaming.operator.functionstream)</span><br><span class="line">            AggFunctionOp (com.huawei.streaming.operator.functionstream)</span><br><span class="line">            SplitOp (com.huawei.streaming.operator.functionstream)</span><br><span class="line">            UnionFunctionOp (com.huawei.streaming.operator.functionstream)</span><br><span class="line">            SelfJoinFunctionOp (com.huawei.streaming.operator.functionstream)</span><br><span class="line">            FunctorOp (com.huawei.streaming.operator.functionstream)</span><br><span class="line">            FilterFunctionOp (com.huawei.streaming.operator.functionstream)</span><br><span class="line">        OutputOperator (com.huawei.streaming.operator)      <span class="comment">//输出算子</span></span><br><span class="line">        FunctionStreamOperator (com.huawei.streaming.operator)</span><br><span class="line">        InputOperator (com.huawei.streaming.operator)       <span class="comment">//输入算子</span></span><br></pre></td></tr></table></figure>
<p>IRichOperator流处理算子基本接口: 所有的流处理相关的算子实现，都来源于这个算子, 所有的外部Storm实现，均依赖于这个接口  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRichOperator</span> <span class="keyword">extends</span> <span class="title">IOperator</span>, <span class="title">Configurable</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getOperatorId</span><span class="params">()</span></span>;                     <span class="comment">//获取算子id</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getParallelNumber</span><span class="params">()</span></span>;                    <span class="comment">//获取算子并发度</span></span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getInputStream</span><span class="params">()</span></span>;              <span class="comment">//获取输入流名称, 多个输入流</span></span><br><span class="line">    <span class="function">String <span class="title">getOutputStream</span><span class="params">()</span></span>;                   <span class="comment">//获取输出流名称</span></span><br><span class="line">    Map&lt;String, IEventType&gt; getInputSchema();   <span class="comment">//获取输入schema, &lt;key是输入流名称,IEventType是输入流的Schema&gt;</span></span><br><span class="line">    <span class="function">IEventType <span class="title">getOutputSchema</span><span class="params">()</span></span>;               <span class="comment">//获取输出schema</span></span><br><span class="line">    Map&lt;String, GroupInfo&gt; getGroupInfo();      <span class="comment">//获取分组信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过ExecutorPlanGenerator生成的application.Application则是生成可执行的执行计划. 可执行指的是可以运行在Storm引擎.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Application apiApplication)</span> </span>&#123;</span><br><span class="line">    parseUserDefineds(apiApplication, isStartFromDriver);</span><br><span class="line">    com.huawei.streaming.application.Application app = generatorPlan(apiApplication);</span><br><span class="line">    submit(app);                    <span class="comment">//③ 提交Application</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有物理执行计划api.Application生成可执行计划application.Application(最终生成的，可以提交的应用程序)</span></span><br><span class="line"><span class="keyword">private</span> com.huawei.streaming.application.<span class="function">Application <span class="title">generatorPlan</span><span class="params">(Application apiApplication)</span> </span>&#123;</span><br><span class="line">    preExecute(apiApplication);     <span class="comment">//执行器执行之前的钩子</span></span><br><span class="line">    <span class="keyword">new</span> PhysicPlanChecker().check(apiApplication);</span><br><span class="line">    <span class="comment">//① 用户自定义的处理: 执行计划的组装, 构建application, 表达式的解析被延迟到这里来实现</span></span><br><span class="line">    com.huawei.streaming.application.Application app = generator.generate(apiApplication);  </span><br><span class="line">    preSubmit(app);                 <span class="comment">//提交执行计划之前的钩子</span></span><br><span class="line">    executorChecker.check(app);     <span class="comment">//② 执行计划检查</span></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志中<code>start to execute application</code>, 在生成器工作之前会<code>parseUserDefineds</code>设置一些用户自定义的准备工作:比如注册jar包,注册函数,打包等发生在parseUserDefineds.    </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">24</span> | INFO  | [main] | start to execute application example | com.huawei.streaming.cql.executor.PhysicalPlanExecutor (PhysicalPlanExecutor.java:<span class="number">127</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">25</span> | INFO  | [main] | start to unzip jar stream-storm-<span class="number">1.0</span>-jar-with-dependencies.jar | com.huawei.streaming.cql.executor.mergeuserdefinds.JarExpander (JarExpander.java:<span class="number">79</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">25</span> | INFO  | [main] | unzip jar /<span class="keyword">private</span>/var/folders/xc/x0b8crk9667ddh1zhfs29_zr0000gn/T/da6d53114b1f49458c0e6329553b1ff9/stream-storm-<span class="number">1.0</span>-jar-with-dependencies.jar to /<span class="keyword">private</span>/var/folders/xc/x0b8crk9667ddh1zhfs29_zr0000gn/T/da6d53114b1f49458c0e6329553b1ff9/jartmp | com.huawei.streaming.cql.executor.mergeuserdefinds.JarExpander (JarExpander.java:<span class="number">91</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">30</span> | INFO  | [main] | finished to unzip jar to dir | com.huawei.streaming.cql.executor.mergeuserdefinds.JarExpander (JarExpander.java:<span class="number">84</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">30</span> | INFO  | [main] | start to copy ch | com.huawei.streaming.cql.executor.mergeuserdefinds.JarFilesMerger (JarFilesMerger.java:<span class="number">82</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">38</span> | INFO  | [main] | finished to package jar | com.huawei.streaming.cql.executor.mergeuserdefinds.JarPacker (JarPacker.java:<span class="number">68</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Schema_-&gt;_TupleEventType">Schema -&gt; TupleEventType</h4><p>前面的第一个Topology的CQL语句:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">INPUT</span> STREAM s(<span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="keyword">STRING</span>, <span class="keyword">type</span> <span class="built_in">INT</span>) <span class="keyword">SOURCE</span> randomgen PROPERTIES ( timeUnit = <span class="string">"SECONDS"</span>, <span class="keyword">period</span> = <span class="string">"1"</span>, eventNumPerperiod = <span class="string">"1"</span>, isSchedule = <span class="string">"true"</span> );</span></span><br><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">OUTPUT</span> STREAM rs(<span class="keyword">type</span> <span class="built_in">INT</span>, cc <span class="built_in">INT</span>) SINK consoleOutput;</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STREAM rs <span class="keyword">SELECT</span> <span class="keyword">type</span>, <span class="keyword">COUNT</span>(<span class="keyword">id</span>) <span class="keyword">as</span> cc</span><br><span class="line"><span class="keyword">FROM</span> s[<span class="keyword">RANGE</span> <span class="number">20</span> SECONDS BATCH]</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">5</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">type</span>;</span></span><br></pre></td></tr></table></figure>
<p>生成可执行计划对应的日志, 会解析schema和算子.   </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | start to generator executor application <span class="keyword">for</span> app example | com.huawei.streaming.cql.executor.ExecutorPlanGenerator (ExecutorPlanGenerator.java:<span class="number">102</span>)</span><br><span class="line"></span><br><span class="line">解析schemas时, 添加输入和输出的Schema, 转换成EventType.  </span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | AddEventType enter, the eventtypeName is:s. | com.huawei.streaming.event.EventTypeMng (EventTypeMng.java:<span class="number">73</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | AddEventType enter, the eventtypeName is:rs. | com.huawei.streaming.event.EventTypeMng (EventTypeMng.java:<span class="number">73</span>)</span><br><span class="line"></span><br><span class="line">解析算子: <span class="number">1</span>)解析二元表达式(属性值表达式) id &gt; <span class="number">5</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | start to parse cql : (s.id &gt; <span class="number">5</span>) | com.huawei.streaming.cql.semanticanalyzer.parser.ApplicationParser (ApplicationParser.java:<span class="number">44</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | Parse Completed | com.huawei.streaming.cql.semanticanalyzer.parser.ApplicationParser (ApplicationParser.java:<span class="number">69</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | start to create binary Expressions. | com.huawei.streaming.cql.executor.expressioncreater.PropertyValueExpressionCreator (BinaryExpressionCreator.java:<span class="number">54</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | Parse Completed, cql : s.type,  count( s.id )  | com.huawei.streaming.cql.semanticanalyzer.parser.SelectClauseParser (SelectClauseParser.java:<span class="number">68</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)解析 group by</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | start to parse cql : s.type | com.huawei.streaming.cql.semanticanalyzer.parser.GroupbyClauseParser (GroupbyClauseParser.java:<span class="number">45</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | Parse Completed | com.huawei.streaming.cql.semanticanalyzer.parser.GroupbyClauseParser (GroupbyClauseParser.java:<span class="number">68</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | start to parse cql : s.type | com.huawei.streaming.cql.semanticanalyzer.parser.GroupbyClauseParser (GroupbyClauseParser.java:<span class="number">45</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | Parse Completed | com.huawei.streaming.cql.semanticanalyzer.parser.GroupbyClauseParser (GroupbyClauseParser.java:<span class="number">68</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)聚合算子 count(id)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | start to create aggregate service | com.huawei.streaming.cql.executor.operatorviewscreater.AggregateServiceViewCreator (AggregateServiceViewCreator.java:<span class="number">89</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前面在submit之前已经start to parse cql过一次了,这里为什么还会再次parse?<br>答: 前面只是LazyTask懒解析,其实还是没有开始的. 那为什么要在这里才开始? 因为解析完schema后, 就该轮到operator的解析了.   </p>
</blockquote>
<p>生成的可执行计划会解析Application中的Schema和Operators,经过重新组装,设置到可执行的Application中.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> com.huawei.streaming.application.<span class="function">Application <span class="title">generate</span><span class="params">(Application vap)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="string">"start to generator executor application for app "</span> + vap.getApplicationId());</span><br><span class="line">    apiApplication = vap;</span><br><span class="line">    createEmptyApplication(vap.getApplicationId());</span><br><span class="line">    parseUserDefineds(vap);     <span class="comment">//用户自定义的处理</span></span><br><span class="line">    parseSchemas();             <span class="comment">//解析所有的Schema，构建schema信息</span></span><br><span class="line">    parseOperators();           <span class="comment">//解析所有的Operator,构建OperatorInfo. 整理Operator中的上下级关系</span></span><br><span class="line">    <span class="keyword">return</span> executorApp;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析Schema会将Schema转换为IEvent事件: TupleEventType. Schema中的Column会转换为TupleEventType的Attribute.而schemaName仍然不变.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleEventType</span> <span class="keyword">implements</span> <span class="title">IEventType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;            <span class="comment">//schemaName,表名</span></span><br><span class="line">    <span class="keyword">private</span> Attribute[] schema;     <span class="comment">//schemas, 所有列</span></span><br><span class="line">    <span class="keyword">private</span> String[] attNames;      <span class="comment">//所有列的列名</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt; ? &gt;[] attTypes;  <span class="comment">//所有列的列类型</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; attid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Schema的管理类用Map结构保存schemaName/eventTypeName和对应的Schema/TupleEventType: 表名-&gt;表结构.   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventTypeMng</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IEventType&gt; schemas;            <span class="comment">//MAP: 数据类型名称 =&gt; 具体数据类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEventType</span><span class="params">(IEventType schema)</span> </span>&#123;</span><br><span class="line">        schemas.put(schema.getEventTypeName(), schema); <span class="comment">//数据类型|事件类型|表名schemaName|streamName流名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样算子管理OperatorMng则用三个Map分别管理输入,输出,功能算子. Map的key是operatorId,value是Operator算子本身.   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorMng</span></span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> List&lt;IRichOperator&gt; sortedFunctions;    <span class="comment">//DFG排序后的功能算子列表，作为创建Storm拓扑顺序的基础(输出和功能算子组成--&gt;Bolt)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IRichOperator&gt; inputs;      <span class="comment">//输入算子 --&gt; Spout</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IRichOperator&gt; functions;   <span class="comment">//功能算子</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IRichOperator&gt; outputs;     <span class="comment">//输出算子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算子解析">算子解析</h4><p>算子解析: 这里的解析是为了使得输入和输出算子统一，避免用户自定义和系统内置的算子对外表现不一致处理起来的麻烦<br>由于输入和输出算子中存在特例，即针对文件，tcp，kafka等编写了特例, 所以需要首先将他们抽象化，之后再来处理  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseOperators</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String, Operator&gt; opts = formatOperators();                     <span class="comment">//① 输入输出算子抽象化</span></span><br><span class="line">    Map&lt;String, AbsOperator&gt; opMappings = createOperatorInfos(opts);    <span class="comment">//② 算子 解析</span></span><br><span class="line">    combineOperators(opMappings);                                       <span class="comment">//③ 整理算子顺序</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, AbsOperator&gt; et : opMappings.entrySet())&#123;        <span class="comment">//④ 添加算子到Application</span></span><br><span class="line">        IRichOperator operator = et.getValue();</span><br><span class="line">        <span class="comment">//如果没有输入，也算是input</span></span><br><span class="line">        <span class="keyword">if</span> (operator <span class="keyword">instanceof</span> InputOperator)&#123;</span><br><span class="line">            executorApp.addInputStream(operator);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有输出，也算是output</span></span><br><span class="line">        <span class="keyword">if</span> (operator <span class="keyword">instanceof</span> OutputOperator)&#123;</span><br><span class="line">            executorApp.addOutputStream(operator);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不是输入输出,就是功能算子</span></span><br><span class="line">        executorApp.addFunctionStream(operator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Operator是算子, AbsOperator则是流处理算子(继承IRichOperator). 它们的转换由OperatorInfoCreatorFactory.buildStreamOperator完成.   </p>
<p><img src="http://img.blog.csdn.net/20151127114702874" alt="stream-aboperators"></p>
<p>combineOperators会将算子用OperatorTransition进行连接: 梳理operatorInfo之间的上下级关系  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineOperators</span><span class="params">(Map&lt;String, AbsOperator&gt; operatorInfos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//算子之间的连接</span></span><br><span class="line">    <span class="keyword">for</span> (OperatorTransition ot : apiApplication.getOpTransition()) &#123;</span><br><span class="line">        <span class="comment">//获取连接的入口和出口算子</span></span><br><span class="line">        String fromOpId = ot.getFromOperatorId();</span><br><span class="line">        String toOpId = ot.getToOperatorId();</span><br><span class="line">        String streamName = ot.getStreamName();</span><br><span class="line">        DistributeType distributedType = ot.getDistributedType();</span><br><span class="line">        String distributedFields = ot.getDistributedFields();</span><br><span class="line">        <span class="comment">//连接的Schema, 对于From和To都是使用相同的Schema</span></span><br><span class="line">        String outputSchemaName = ot.getSchemaName();</span><br><span class="line">        distributedFields = ExecutorUtils.removeStreamName(distributedFields);            </span><br><span class="line">        TupleEventType outputSchema = (TupleEventType)(executorApp.getEventType(outputSchemaName));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//operatorInfos是所有的算子集合, 根据传入的fromOpId或者toOpId,从集合中找出对应的算子</span></span><br><span class="line">        combineFromTransition(operatorInfos, fromOpId, streamName, outputSchema);</span><br><span class="line">        combineToTransition(operatorInfos, toOpId, streamName, distributedType, distributedFields, outputSchema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FromTransition: 连线的from算子的输出是outputSchema  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineFromTransition</span><span class="params">(Map&lt;String, AbsOperator&gt; operatorInfos, String fromOpId, String streamName, TupleEventType outputSchema)</span></span>&#123;</span><br><span class="line">    sConfig.put(StreamingConfig.STREAMING_INNER_OUTPUT_SCHEMA, outputSchema);</span><br><span class="line">    sConfig.put(StreamingConfig.STREAMING_INNER_OUTPUT_STREAM_NAME, streamName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ToTransition: 连线的to算子的输入是outputSchema. <code>这里outputSchema命名为schema似乎更好</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineToTransition</span><span class="params">(Map&lt;String, AbsOperator&gt; operatorInfos, String toOpId, String streamName,</span><br><span class="line">    DistributeType distributedType, String distributedFields, TupleEventType outputSchema)</span> </span>&#123;</span><br><span class="line">    sConfig.put(StreamingConfig.STREAMING_INNER_INPUT_STREAM_NAME, streamName);</span><br><span class="line">    sConfig.put(StreamingConfig.STREAMING_INNER_INPUT_SCHEMA, outputSchema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于Graph中的顶点A -&gt; 边 -&gt; 顶点B. Transition就类似于边, 连接着左右两边的算子, 分别是From算子和To算子.  </p>
<h3 id="SubmitApplication_-&gt;_launch_Application">SubmitApplication -&gt; launch Application</h3><p>SubmitTask.submitApplication -&gt; PhysicalPlanExecutor.execute -&gt; PhysicalPlanExecutor.submit(application.Application) -&gt;<br>StormApplication.launch -&gt; createTopology 创建拓扑, 对于Storm的程序而言, 构成拓扑的组件包括Spouts和Bolts.<br>这些数据都来自于Application的输入,输出和功能算子. 由于Storm只有两种组件Spout和Bolt, 所以输入算子归于Spout,输出和功能算子都属于Bolt.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createSpouts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt; ? extends IRichOperator&gt; sources = getInputStreams(); <span class="comment">//获得所有源算子信息: OperatorMng.inputs</span></span><br><span class="line">    checkInputStreams(sources);</span><br><span class="line">    <span class="keyword">for</span> (IRichOperator input : sources) &#123;</span><br><span class="line">        StormSpout spout = <span class="keyword">new</span> StormSpout();</span><br><span class="line">        spout.setOperator(input);</span><br><span class="line">        builder.setSpout(input.getOperatorId(), spout, input.getParallelNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createBolts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;IRichOperator&gt; orderedFunOp = genFunctionOpsOrder();   <span class="comment">//获取已经排好序的功能算子，这个功能算子包含output算子</span></span><br><span class="line">    <span class="keyword">for</span> (IRichOperator operator : orderedFunOp) &#123;</span><br><span class="line">        setOperatorGrouping(operator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>哪些Operator算子会作为Bolt, OutpoutBolt, Spout都是由OperatorMng管理的比如getInputStreams,genFunctionOpsOrder<br>这样创建的Bolt会直接依赖于对应的Operator, 在处理Bolt时,就不需要再判断是哪一种类型的Operator了.<br>所以正是由于对算子的种类进行了分离(输入,输出,功能)才使得处理Storm的component时变得容易.  </p>
</blockquote>
<h4 id="Bolt_Grouping">Bolt Grouping</h4><p>在开发Storm应用程序时, 一般是在Storm的Topology代码中创建Bolt并直接设置Bolt的分组策略.<br>假设有这样的Topology, Bolt1输出到Bolt3和Bolt4, Bolt2输出到Bolt3(一个Bolt可以有多个输出,也可以由多个输入).    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">             |------ |Bolt4|</span><br><span class="line">|Bolt1| -----|</span><br><span class="line">             |------ |Bolt3|</span><br><span class="line">|Bolt2| -----|</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bolt1有两个输出流, 输出字段都是一样的, 两个输出流的名称stream-id不一样</span></span><br><span class="line">builder.setBolt(<span class="string">"bolt1"</span>, <span class="keyword">new</span> Bolt1(), <span class="number">2</span>)        </span><br><span class="line">            declarer.declareStream(<span class="string">"streamA"</span>, <span class="keyword">new</span> Fields(<span class="string">"f1"</span>,<span class="string">"f2"</span>))</span><br><span class="line">            declarer.declareStream(<span class="string">"streamB"</span>, <span class="keyword">new</span> Fields(<span class="string">"f1"</span>,<span class="string">"f2"</span>))</span><br><span class="line"><span class="comment">//Bolt2只有一个输出流</span></span><br><span class="line">builder.setBolt(<span class="string">"bolt2"</span>, <span class="keyword">new</span> Bolt2(), <span class="number">2</span>)</span><br><span class="line">            declarer.declareStream(<span class="string">"streamC"</span>, <span class="keyword">new</span> Fields(<span class="string">"f1"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bolt3接收Bolt1的streamA流使用字段分组, 接收Bolt2的streamC流使用shuffle分组</span></span><br><span class="line">builder.setBolt(<span class="string">"bolt3"</span>, <span class="keyword">new</span> Bolt3(), <span class="number">4</span>)</span><br><span class="line">        .fieldsGrouping(<span class="string">"bolt1"</span>, <span class="string">"streamA"</span>, <span class="keyword">new</span> Field(<span class="string">"f1"</span>))</span><br><span class="line">        .shuffleGrouping(<span class="string">"bolt2"</span>, <span class="string">"streamC"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bolt4接收Bolt1的streamB流使用字段分组, 分组字段是Bolt1产生的f2字段.  </span></span><br><span class="line">builder.setBolt(<span class="string">"bolt4"</span>, <span class="keyword">new</span> Bolt4(), <span class="number">3</span>)</span><br><span class="line">        .fieldsGrouping(<span class="string">"bolt1"</span>, <span class="string">"streamB"</span>, , <span class="keyword">new</span> Field(<span class="string">"f2"</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>setBolt时设置的componentId/operatorId都是自己Bolt, 分组时的componentId则是输入的componentId/operatorId.  </p>
</blockquote>
<p>通过解析CQL的分组以及算子/组件之间的连接, 现在就不需要在Topology写死了. 因此需要框架能够动态地构建Topology.  </p>
<blockquote>
<p>为什么IRichOperator的getInputStream()和getOutputStream()表示的是输入流和输出流的名称, 而不是输入流对象和输出流对象(比如算子本身).<br>这是因为Operator算子会用于Topology的Spout/Bolt, 创建完Spout/Bolt之后, 用于构建Topology其他必要的信息除了分组外,<br>还有Storm的component-id对应算子的id 和 Storm的stream-id对应算子的输入/输出流名称  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOperatorGrouping</span><span class="params">(IRichOperator operator)</span> </span>&#123;</span><br><span class="line">    BoltDeclarer bolt = createBoltDeclarer(operator);</span><br><span class="line">    <span class="comment">//一个Bolt可能有多个输入即多个InputStream, 同时输出也可能有多个: 设置不同的Grouping策略</span></span><br><span class="line">    <span class="comment">//注意: Bolt设置分组时的componentId是其输入源的ComponentId,而不是自己的componentId, 自己是在builder.setBolt时设置的</span></span><br><span class="line">    <span class="keyword">for</span> (String strname : operator.getInputStream()) &#123;              <span class="comment">//strname是当前算子的输入流名称</span></span><br><span class="line">        GroupInfo groupInfo = operator.getGroupInfo().get(strname); <span class="comment">//算子的分组信息</span></span><br><span class="line">        setBoltGrouping(bolt, strname, groupInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBoltGrouping</span><span class="params">(BoltDeclarer bolt, String strname, GroupInfo groupInfo)</span> </span>&#123;        </span><br><span class="line">    DistributeType distribute = groupInfo.getDitributeType();</span><br><span class="line">    <span class="keyword">switch</span> (distribute) &#123;</span><br><span class="line">        <span class="keyword">case</span> FIELDS:</span><br><span class="line">            Fields fields = <span class="keyword">new</span> Fields(groupInfo.getFields());</span><br><span class="line">            <span class="comment">//根据输入流的名称, 获取这个输入流是个什么算子, 为的是获得这个输入算子的operatorId,作为分组策略的第一个参数</span></span><br><span class="line">            IRichOperator operator = getOperatorByOutputStreamName(strname);</span><br><span class="line">            <span class="comment">//字段分组三个参数分别表示: componentId, streamId, fields. 这里的componentId表示从哪个数据源接入数据,而不是当前算子的operatorId</span></span><br><span class="line">            bolt.fieldsGrouping(operator.getOperatorId(), strname, fields);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//... 其他分组类型 ...   </span></span><br><span class="line">        <span class="keyword">default</span>:               </span><br><span class="line">            setDefaultBoltGrouping(bolt, strname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDefaultBoltGrouping</span><span class="params">(BoltDeclarer bolt, String strname)</span> </span>&#123;</span><br><span class="line">    IRichOperator operator = getOperatorByOutputStreamName(strname);</span><br><span class="line">    <span class="comment">//shuffle分组两个参数分别表示: 输入流的operatorId/componentId, streamId</span></span><br><span class="line">    bolt.shuffleGrouping(operator.getOperatorId(), strname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Operator算子的id会作为Storm中Spout/Bolt的component-id, 而Operator的输入流/输出流名称是作为Spout/Bolt的stream-id.<br>component-id只是用于区别不同的组件,或者用于从哪个输入组件获取数据. 而stream-id则可以作为分流/多流/合并流等.  </p>
</blockquote>
<h4 id="Bolt_Creation">Bolt Creation</h4><p>createBolts设置Operator的分组策略, 首先创建IRichBolt,并返回Bolt的声明BoltDeclarer,以便后续操作可以在BoltDeclarer继续进行(比如上面的分组策略).  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BoltDeclarer <span class="title">createBoltDeclarer</span><span class="params">(IRichOperator operator)</span></span>&#123;</span><br><span class="line">    IRichBolt bolt;</span><br><span class="line">    <span class="keyword">if</span> ((operator <span class="keyword">instanceof</span> FunctionOperator) || (operator <span class="keyword">instanceof</span> FunctionStreamOperator)) &#123;</span><br><span class="line">        bolt = createStormBolt(operator);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        bolt = createOutputStormBolt(operator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.setBolt(operator.getOperatorId(), bolt, operator.getParallelNumber());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> IRichBolt <span class="title">createOutputStormBolt</span><span class="params">(IRichOperator f)</span></span>&#123;</span><br><span class="line">    StormOutputBolt outputbolt = <span class="keyword">new</span> StormOutputBolt();</span><br><span class="line">    outputbolt.setOperator(f);</span><br><span class="line">    <span class="keyword">return</span> outputbolt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> IRichBolt <span class="title">createStormBolt</span><span class="params">(IRichOperator f)</span></span>&#123;</span><br><span class="line">    StormBolt stormbolt = <span class="keyword">new</span> StormBolt();</span><br><span class="line">    stormbolt.setOperator(f);</span><br><span class="line">    <span class="keyword">return</span> stormbolt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StormSpout,StormBolt,StormOutputBolt都是对Storm的组件的封装. 除了继承各自的IRichSpout和IRichBolt外,还要实现StreamAdapter接口的setOperator方法.<br>流处理算子适配接口: 依靠这个接口，将流处理的算子注入到具体的Storm的Spout/Bolt中. <code>创建Bolt为啥不用构造函数一句话的事儿: new StormBolt(operator)</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StormSpout</span> <span class="keyword">implements</span> <span class="title">IRichSpout</span>, <span class="title">StreamAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IRichOperator input;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOperator</span><span class="params">(IRichOperator operator)</span></span>&#123;</span><br><span class="line">        input = operator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StormOutputBolt</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span>, <span class="title">StreamAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutputCollector outputCollector;</span><br><span class="line">    <span class="keyword">private</span> OutputOperator output;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOperator</span><span class="params">(IRichOperator operator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.output = (OutputOperator)operator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StormBolt的execute方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span> </span>&#123;</span><br><span class="line">    String sourceStreamName = input.getSourceStreamId();        <span class="comment">//获取Tuple的输入流stream-id</span></span><br><span class="line">    List&lt;String&gt; inStreams = functionStream.getInputStream();   <span class="comment">//输入流名称列表,因为一个Bolt可以有多个输入流</span></span><br><span class="line">    <span class="keyword">for</span> (String streamName : inStreams) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sourceStreamName.equals(streamName)) <span class="keyword">continue</span>;     <span class="comment">//只有Tuple的输入流stream-id和IRichOperator的输入流名称相同时,才处理这个Tuple</span></span><br><span class="line">        TupleEvent event = TupleTransform.tupeToEvent(input, functionStream.getInputSchema().get(streamName));</span><br><span class="line">        functionStream.execute(streamName, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | start to submit application example | com.huawei.streaming.cql.executor.PhysicalPlanExecutor (PhysicalPlanExecutor.java:<span class="number">201</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | reset submit jar to /<span class="keyword">private</span>/var/folders/xc/x0b8crk9667ddh1zhfs29_zr0000gn/T/example<span class="number">.5f</span>8ed0baaeb243a49308fd75144cf715.jar | com.huawei.streaming.storm.StormApplication (StormApplication.java:<span class="number">314</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | Using defaults.yaml from resources | backtype.storm.utils.Utils (Utils.java:<span class="number">253</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | The baseSleepTimeMs [<span class="number">2000</span>] the maxSleepTimeMs [<span class="number">60000</span>] the maxRetries [<span class="number">5</span>] | backtype.storm.utils.StormBoundedExponentialBackoffRetry (StormBoundedExponentialBackoffRetry.java:<span class="number">47</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | Using defaults.yaml from resources | backtype.storm.utils.Utils (Utils.java:<span class="number">253</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | GenFunctionOpsOrder enter. | com.huawei.streaming.application.OperatorMng (OperatorMng.java:<span class="number">205</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | Using defaults.yaml from resources | backtype.storm.utils.Utils (Utils.java:<span class="number">253</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | Generated ZooKeeper secret payload <span class="keyword">for</span> MD5-digest: -<span class="number">5668598407594625313</span>:-<span class="number">5703359794945963404</span> | backtype.storm.StormSubmitter (StormSubmitter.java:<span class="number">82</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">39</span> | INFO  | [main] | Uploading topology jar /<span class="keyword">private</span>/var/folders/xc/x0b8crk9667ddh1zhfs29_zr0000gn/T/example<span class="number">.5f</span>8ed0baaeb243a49308fd75144cf715.jar to assigned location: storm-local/nimbus/inbox/stormjar-a5b95134-e3f2-<span class="number">431</span>d-b675-<span class="number">924</span>d8c468cf3.jar | backtype.storm.StormSubmitter (StormSubmitter.java:<span class="number">371</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">40</span> | INFO  | [main] | Successfully uploaded topology jar to assigned location: storm-local/nimbus/inbox/stormjar-a5b95134-e3f2-<span class="number">431</span>d-b675-<span class="number">924</span>d8c468cf3.jar | backtype.storm.StormSubmitter (StormSubmitter.java:<span class="number">396</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">40</span> | INFO  | [main] | Finished submitting topology: example | backtype.storm.StormSubmitter (StormSubmitter.java:<span class="number">248</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">40</span> | INFO  | [main] | <span class="keyword">delete</span> user packed jar after submit | com.huawei.streaming.cql.executor.PhysicalPlanExecutor (PhysicalPlanExecutor.java:<span class="number">156</span>)</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">32</span>:<span class="number">40</span> | INFO  | [main] | unRegister jars from <span class="keyword">class</span> loader. | com.huawei.streaming.cql.DriverContext (DriverContext.java:<span class="number">427</span>)</span><br></pre></td></tr></table></figure>
			  
		</div>

		<!-- pagination -->
	  

		
  


	</div>
	<div class="col-md-4">
		
			
				<div id="sidebar">
	 			
	 					
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2015/11/29/2015-07-10-drill-log/"  > <i class="mdi-editor-insert-drive-file"></i>Apache Drill源码分析之日志</a>
      </li>
    
      <li>
        <a href="/2015/11/29/2015-11-27-StreamCQL-application/"  > <i class="mdi-editor-insert-drive-file"></i>StreamCQL源码分析之application</a>
      </li>
    
      <li>
        <a href="/2015/11/29/2015-07-26-drill-fragment-execute/"  > <i class="mdi-editor-insert-drive-file"></i>Apache Drill源码分析之execute</a>
      </li>
    
      <li>
        <a href="/2015/11/29/2015-07-15-drill-fragments/"  > <i class="mdi-editor-insert-drive-file"></i>Apache Drill源码分析之fragment</a>
      </li>
    
      <li>
        <a href="/2015/11/29/2015-07-14-drill-logical/"  > <i class="mdi-editor-insert-drive-file"></i>Apache Drill源码分析之逻辑计划</a>
      </li>
    
  </ul>
</div>


	 				
	 					
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li> <a href="http://www.github.com/zqhuxyuan" title="" target="_blank"> <i class="mdi-action-launch"></i> GitHub</a></li>
	
		<li> <a href="http://www.weibo.com/xuyuantree" title="twitter的本地化版本" target="_blank"> <i class="mdi-action-launch"></i> 微博</a></li>
	
	</ul>
</div>


	 				
	 			</div>
			
		
	</div>

</div>


			<footer>
				

<p>
  由 <a href="https://hexo.io">hexo</a> 强力驱动 | 搭载 <a href="https://github.com/wayou/hexo-theme-material">material</a> 主题
</p>
<p>
  &copy; 2015 <a href="http://github.com/zqhxuyuan"> zqhxuyuan </a>
</p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

			</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
